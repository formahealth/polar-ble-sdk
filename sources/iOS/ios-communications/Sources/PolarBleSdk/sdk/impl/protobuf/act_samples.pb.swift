// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: act_samples.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Data_PbActivityInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data_PbActivityInfo.ActivityClass {
    get {return _value ?? .sleep}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  /// Local time is used, because the design is originally implemented in local time
  var timeStamp: PbLocalDateTime {
    get {return _timeStamp ?? PbLocalDateTime()}
    set {_timeStamp = newValue}
  }
  /// Returns true if `timeStamp` has been explicitly set.
  var hasTimeStamp: Bool {return self._timeStamp != nil}
  /// Clears the value of `timeStamp`. Subsequent reads from it will return its default value.
  mutating func clearTimeStamp() {self._timeStamp = nil}

  var factor: Float {
    get {return _factor ?? 0}
    set {_factor = newValue}
  }
  /// Returns true if `factor` has been explicitly set.
  var hasFactor: Bool {return self._factor != nil}
  /// Clears the value of `factor`. Subsequent reads from it will return its default value.
  mutating func clearFactor() {self._factor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ActivityClass: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case sleep // = 1
    case sedentary // = 2
    case light // = 3
    case continuousModerate // = 4
    case intermittentModerate // = 5
    case continuousVigorous // = 6
    case intermittentVigorous // = 7
    case nonWear // = 8

    init() {
      self = .sleep
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .sleep
      case 2: self = .sedentary
      case 3: self = .light
      case 4: self = .continuousModerate
      case 5: self = .intermittentModerate
      case 6: self = .continuousVigorous
      case 7: self = .intermittentVigorous
      case 8: self = .nonWear
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .sleep: return 1
      case .sedentary: return 2
      case .light: return 3
      case .continuousModerate: return 4
      case .intermittentModerate: return 5
      case .continuousVigorous: return 6
      case .intermittentVigorous: return 7
      case .nonWear: return 8
      }
    }

  }

  init() {}

  fileprivate var _value: Data_PbActivityInfo.ActivityClass? = nil
  fileprivate var _timeStamp: PbLocalDateTime? = nil
  fileprivate var _factor: Float? = nil
}

struct Data_PbActivitySamples: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Date and time when the sample was created for the first time
  /// Local time is used, because the design is originally implemented in local time
  var startTime: PbLocalDateTime {
    get {return _storage._startTime ?? PbLocalDateTime()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Recording interval of met samples in this file
  var metRecordingInterval: PbDuration {
    get {return _storage._metRecordingInterval ?? PbDuration()}
    set {_uniqueStorage()._metRecordingInterval = newValue}
  }
  /// Returns true if `metRecordingInterval` has been explicitly set.
  var hasMetRecordingInterval: Bool {return _storage._metRecordingInterval != nil}
  /// Clears the value of `metRecordingInterval`. Subsequent reads from it will return its default value.
  mutating func clearMetRecordingInterval() {_uniqueStorage()._metRecordingInterval = nil}

  /// Recording interval of step samples in this file
  var stepsRecordingInterval: PbDuration {
    get {return _storage._stepsRecordingInterval ?? PbDuration()}
    set {_uniqueStorage()._stepsRecordingInterval = newValue}
  }
  /// Returns true if `stepsRecordingInterval` has been explicitly set.
  var hasStepsRecordingInterval: Bool {return _storage._stepsRecordingInterval != nil}
  /// Clears the value of `stepsRecordingInterval`. Subsequent reads from it will return its default value.
  mutating func clearStepsRecordingInterval() {_uniqueStorage()._stepsRecordingInterval = nil}

  /// met samples
  var metSamples: [Float] {
    get {return _storage._metSamples}
    set {_uniqueStorage()._metSamples = newValue}
  }

  /// step samples
  var stepsSamples: [UInt32] {
    get {return _storage._stepsSamples}
    set {_uniqueStorage()._stepsSamples = newValue}
  }

  /// Activity class changes
  var activityInfo: [Data_PbActivityInfo] {
    get {return _storage._activityInfo}
    set {_uniqueStorage()._activityInfo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data"

extension Data_PbActivityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbActivityInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "time_stamp"),
    3: .same(proto: "factor"),
  ]

  public var isInitialized: Bool {
    if let v = self._timeStamp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeStamp) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._factor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timeStamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._factor {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_PbActivityInfo, rhs: Data_PbActivityInfo) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._timeStamp != rhs._timeStamp {return false}
    if lhs._factor != rhs._factor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbActivityInfo.ActivityClass: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SLEEP"),
    2: .same(proto: "SEDENTARY"),
    3: .same(proto: "LIGHT"),
    4: .same(proto: "CONTINUOUS_MODERATE"),
    5: .same(proto: "INTERMITTENT_MODERATE"),
    6: .same(proto: "CONTINUOUS_VIGOROUS"),
    7: .same(proto: "INTERMITTENT_VIGOROUS"),
    8: .same(proto: "NON_WEAR"),
  ]
}

extension Data_PbActivitySamples: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbActivitySamples"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "met_recording_interval"),
    3: .standard(proto: "steps_recording_interval"),
    4: .standard(proto: "met_samples"),
    5: .standard(proto: "steps_samples"),
    7: .standard(proto: "activity_info"),
  ]

  fileprivate class _StorageClass {
    var _startTime: PbLocalDateTime? = nil
    var _metRecordingInterval: PbDuration? = nil
    var _stepsRecordingInterval: PbDuration? = nil
    var _metSamples: [Float] = []
    var _stepsSamples: [UInt32] = []
    var _activityInfo: [Data_PbActivityInfo] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _startTime = source._startTime
      _metRecordingInterval = source._metRecordingInterval
      _stepsRecordingInterval = source._stepsRecordingInterval
      _metSamples = source._metSamples
      _stepsSamples = source._stepsSamples
      _activityInfo = source._activityInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._startTime, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._activityInfo) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._metRecordingInterval) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stepsRecordingInterval) }()
        case 4: try { try decoder.decodeRepeatedFloatField(value: &_storage._metSamples) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._stepsSamples) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._activityInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._metRecordingInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stepsRecordingInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._metSamples.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._metSamples, fieldNumber: 4)
      }
      if !_storage._stepsSamples.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._stepsSamples, fieldNumber: 5)
      }
      if !_storage._activityInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activityInfo, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_PbActivitySamples, rhs: Data_PbActivitySamples) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._metRecordingInterval != rhs_storage._metRecordingInterval {return false}
        if _storage._stepsRecordingInterval != rhs_storage._stepsRecordingInterval {return false}
        if _storage._metSamples != rhs_storage._metSamples {return false}
        if _storage._stepsSamples != rhs_storage._stepsSamples {return false}
        if _storage._activityInfo != rhs_storage._activityInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
