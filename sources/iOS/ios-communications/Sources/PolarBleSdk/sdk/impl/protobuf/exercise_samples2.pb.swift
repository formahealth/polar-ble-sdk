// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exercise_samples2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// SAMPLES2.BPB=PbExerciseSamples2

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
///Exercise samples sync point.
///
///Sync points can be inserted in the data multiple times to synchronize the sample stream
///and reconfigure the granularity and other parameters of the delta stream.
///
///The usage of Sync Points gives possibility and flexibility to reconfigure the stream during
///the packing if the conditions change.
struct Data_PbExerciseSamplesSyncPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sync point index.
  /// Determines the sample index starting from which
  /// this sync info is valid.
  /// For example index = 0 is the starting sync point.
  /// index [n] refers to [n]:th index in the delta data
  var index: UInt32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  /// If exists, this sync point also synchronizes heart rate.
  /// Granularity 1 bps.
  var heartRateSample: UInt32 {
    get {return _heartRateSample ?? 0}
    set {_heartRateSample = newValue}
  }
  /// Returns true if `heartRateSample` has been explicitly set.
  var hasHeartRateSample: Bool {return self._heartRateSample != nil}
  /// Clears the value of `heartRateSample`. Subsequent reads from it will return its default value.
  mutating func clearHeartRateSample() {self._heartRateSample = nil}

  /// If exists, this sync point also synchronizes cadence.
  /// Granularity 1 rounds per minute
  var cadenceSample: UInt32 {
    get {return _cadenceSample ?? 0}
    set {_cadenceSample = newValue}
  }
  /// Returns true if `cadenceSample` has been explicitly set.
  var hasCadenceSample: Bool {return self._cadenceSample != nil}
  /// Clears the value of `cadenceSample`. Subsequent reads from it will return its default value.
  mutating func clearCadenceSample() {self._cadenceSample = nil}

  /// If exists, this sync point also synchronizes speed
  var speedSample: Float {
    get {return _speedSample ?? 0}
    set {_speedSample = newValue}
  }
  /// Returns true if `speedSample` has been explicitly set.
  var hasSpeedSample: Bool {return self._speedSample != nil}
  /// Clears the value of `speedSample`. Subsequent reads from it will return its default value.
  mutating func clearSpeedSample() {self._speedSample = nil}

  /// If exists, this sync point also synchronizes distance
  var distanceSample: Float {
    get {return _distanceSample ?? 0}
    set {_distanceSample = newValue}
  }
  /// Returns true if `distanceSample` has been explicitly set.
  var hasDistanceSample: Bool {return self._distanceSample != nil}
  /// Clears the value of `distanceSample`. Subsequent reads from it will return its default value.
  mutating func clearDistanceSample() {self._distanceSample = nil}

  /// If exists, this sync point also synchronizes forward acceleration
  var forwardAccelerationSample: Float {
    get {return _forwardAccelerationSample ?? 0}
    set {_forwardAccelerationSample = newValue}
  }
  /// Returns true if `forwardAccelerationSample` has been explicitly set.
  var hasForwardAccelerationSample: Bool {return self._forwardAccelerationSample != nil}
  /// Clears the value of `forwardAccelerationSample`. Subsequent reads from it will return its default value.
  mutating func clearForwardAccelerationSample() {self._forwardAccelerationSample = nil}

  /// If exists, this sync point also synchronizes acceleration based
  /// Mean Amplitude Deviation (MAD)
  var accelerationMadSample: Float {
    get {return _accelerationMadSample ?? 0}
    set {_accelerationMadSample = newValue}
  }
  /// Returns true if `accelerationMadSample` has been explicitly set.
  var hasAccelerationMadSample: Bool {return self._accelerationMadSample != nil}
  /// Clears the value of `accelerationMadSample`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationMadSample() {self._accelerationMadSample = nil}

  /// Granularity of speed deltas starting from
  /// this Sync Point. Default [0.001 km/h].
  var speedSampleGranularity: UInt32 {
    get {return _speedSampleGranularity ?? 1000}
    set {_speedSampleGranularity = newValue}
  }
  /// Returns true if `speedSampleGranularity` has been explicitly set.
  var hasSpeedSampleGranularity: Bool {return self._speedSampleGranularity != nil}
  /// Clears the value of `speedSampleGranularity`. Subsequent reads from it will return its default value.
  mutating func clearSpeedSampleGranularity() {self._speedSampleGranularity = nil}

  /// Granularity of distance deltas starting from
  /// this Sync Point. Default [0.1 m].
  var distanceSampleGranularity: UInt32 {
    get {return _distanceSampleGranularity ?? 10}
    set {_distanceSampleGranularity = newValue}
  }
  /// Returns true if `distanceSampleGranularity` has been explicitly set.
  var hasDistanceSampleGranularity: Bool {return self._distanceSampleGranularity != nil}
  /// Clears the value of `distanceSampleGranularity`. Subsequent reads from it will return its default value.
  mutating func clearDistanceSampleGranularity() {self._distanceSampleGranularity = nil}

  /// Granularity of forward acceleration deltas starting from
  /// this Sync Point. Default [0.01 m/s^2].
  var forwardAccelerationSampleGranularity: UInt32 {
    get {return _forwardAccelerationSampleGranularity ?? 100}
    set {_forwardAccelerationSampleGranularity = newValue}
  }
  /// Returns true if `forwardAccelerationSampleGranularity` has been explicitly set.
  var hasForwardAccelerationSampleGranularity: Bool {return self._forwardAccelerationSampleGranularity != nil}
  /// Clears the value of `forwardAccelerationSampleGranularity`. Subsequent reads from it will return its default value.
  mutating func clearForwardAccelerationSampleGranularity() {self._forwardAccelerationSampleGranularity = nil}

  /// Granularity of acceleration MAD deltas starting from
  /// this Sync Point. Default [0.01 mg].
  var accelerationMadSampleGranularity: UInt32 {
    get {return _accelerationMadSampleGranularity ?? 100}
    set {_accelerationMadSampleGranularity = newValue}
  }
  /// Returns true if `accelerationMadSampleGranularity` has been explicitly set.
  var hasAccelerationMadSampleGranularity: Bool {return self._accelerationMadSampleGranularity != nil}
  /// Clears the value of `accelerationMadSampleGranularity`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationMadSampleGranularity() {self._accelerationMadSampleGranularity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _index: UInt32? = nil
  fileprivate var _heartRateSample: UInt32? = nil
  fileprivate var _cadenceSample: UInt32? = nil
  fileprivate var _speedSample: Float? = nil
  fileprivate var _distanceSample: Float? = nil
  fileprivate var _forwardAccelerationSample: Float? = nil
  fileprivate var _accelerationMadSample: Float? = nil
  fileprivate var _speedSampleGranularity: UInt32? = nil
  fileprivate var _distanceSampleGranularity: UInt32? = nil
  fileprivate var _forwardAccelerationSampleGranularity: UInt32? = nil
  fileprivate var _accelerationMadSampleGranularity: UInt32? = nil
}

struct Data_PbExerciseIntervalledSample2List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sample Type, SPEED, DISTANCE etc.
  var sampleType: PbSampleType {
    get {return _sampleType ?? .sampleTypeUndefined}
    set {_sampleType = newValue}
  }
  /// Returns true if `sampleType` has been explicitly set.
  var hasSampleType: Bool {return self._sampleType != nil}
  /// Clears the value of `sampleType`. Subsequent reads from it will return its default value.
  mutating func clearSampleType() {self._sampleType = nil}

  /// Recording interval of samples in milliseconds
  var recordingIntervalMs: UInt32 {
    get {return _recordingIntervalMs ?? 0}
    set {_recordingIntervalMs = newValue}
  }
  /// Returns true if `recordingIntervalMs` has been explicitly set.
  var hasRecordingIntervalMs: Bool {return self._recordingIntervalMs != nil}
  /// Clears the value of `recordingIntervalMs`. Subsequent reads from it will return its default value.
  mutating func clearRecordingIntervalMs() {self._recordingIntervalMs = nil}

  /// Points to which incrementally the deltas are accumulated
  var syncPoint: [Data_PbExerciseSamplesSyncPoint] = []

  /// Indicates the source of certain sample: source and start / stop indexes for the given source
  var sampleSource: [PbSampleSource] = []

  /// Delta coded heart rate samples
  var heartRateSamples: [Int32] = []

  /// Delta coded cadence samples
  var cadenceSamples: [Int32] = []

  /// Delta coded speed samples
  /// Note: Samples are already calibrated samples
  var speedSamples: [Int32] = []

  /// Delta coded distance samples: total distance from the beginning of the exercise
  /// Note: Samples are already calibrated samples
  var distanceSamples: [UInt32] = []

  /// User 1d delta coded acceleration samples as m/s2
  var forwardAccelerationSamples: [Int32] = []

  /// Delta coded acceleration based Mean Amplitude Deviation (MAD) samples as mg
  var accelerationMadSamples: [Int32] = []

  /// User walking/running/standing status samples
  var movingTypeSamples: [PbMovingType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sampleType: PbSampleType? = nil
  fileprivate var _recordingIntervalMs: UInt32? = nil
}

///
///Sample data of the exercise.
///! All fields are required.
public struct Data_PbExerciseSamples2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Exercise samples with sample type specific recording intervals
  var exerciseIntervalledSample2List: [Data_PbExerciseIntervalledSample2List] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Data_PbExerciseSamplesSyncPoint: @unchecked Sendable {}
extension Data_PbExerciseIntervalledSample2List: @unchecked Sendable {}
extension Data_PbExerciseSamples2: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data"

extension Data_PbExerciseSamplesSyncPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbExerciseSamplesSyncPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "heart_rate_sample"),
    3: .standard(proto: "cadence_sample"),
    4: .standard(proto: "speed_sample"),
    5: .standard(proto: "distance_sample"),
    6: .standard(proto: "forward_acceleration_sample"),
    10: .standard(proto: "acceleration_mad_sample"),
    7: .standard(proto: "speed_sample_granularity"),
    8: .standard(proto: "distance_sample_granularity"),
    9: .standard(proto: "forward_acceleration_sample_granularity"),
    11: .standard(proto: "acceleration_mad_sample_granularity"),
  ]

  public var isInitialized: Bool {
    if self._index == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._heartRateSample) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._cadenceSample) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._speedSample) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._distanceSample) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._forwardAccelerationSample) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._speedSampleGranularity) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._distanceSampleGranularity) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._forwardAccelerationSampleGranularity) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self._accelerationMadSample) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._accelerationMadSampleGranularity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._heartRateSample {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cadenceSample {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._speedSample {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._distanceSample {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._forwardAccelerationSample {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._speedSampleGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._distanceSampleGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._forwardAccelerationSampleGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._accelerationMadSample {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._accelerationMadSampleGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_PbExerciseSamplesSyncPoint, rhs: Data_PbExerciseSamplesSyncPoint) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._heartRateSample != rhs._heartRateSample {return false}
    if lhs._cadenceSample != rhs._cadenceSample {return false}
    if lhs._speedSample != rhs._speedSample {return false}
    if lhs._distanceSample != rhs._distanceSample {return false}
    if lhs._forwardAccelerationSample != rhs._forwardAccelerationSample {return false}
    if lhs._accelerationMadSample != rhs._accelerationMadSample {return false}
    if lhs._speedSampleGranularity != rhs._speedSampleGranularity {return false}
    if lhs._distanceSampleGranularity != rhs._distanceSampleGranularity {return false}
    if lhs._forwardAccelerationSampleGranularity != rhs._forwardAccelerationSampleGranularity {return false}
    if lhs._accelerationMadSampleGranularity != rhs._accelerationMadSampleGranularity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseIntervalledSample2List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbExerciseIntervalledSample2List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .standard(proto: "recording_interval_ms"),
    3: .standard(proto: "sync_point"),
    4: .standard(proto: "sample_source"),
    5: .standard(proto: "heart_rate_samples"),
    6: .standard(proto: "cadence_samples"),
    7: .standard(proto: "speed_samples"),
    8: .standard(proto: "distance_samples"),
    9: .standard(proto: "forward_acceleration_samples"),
    11: .standard(proto: "acceleration_mad_samples"),
    10: .standard(proto: "moving_type_samples"),
  ]

  public var isInitialized: Bool {
    if self._sampleType == nil {return false}
    if self._recordingIntervalMs == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.syncPoint) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sampleSource) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._recordingIntervalMs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.syncPoint) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sampleSource) }()
      case 5: try { try decoder.decodeRepeatedSInt32Field(value: &self.heartRateSamples) }()
      case 6: try { try decoder.decodeRepeatedSInt32Field(value: &self.cadenceSamples) }()
      case 7: try { try decoder.decodeRepeatedSInt32Field(value: &self.speedSamples) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.distanceSamples) }()
      case 9: try { try decoder.decodeRepeatedSInt32Field(value: &self.forwardAccelerationSamples) }()
      case 10: try { try decoder.decodeRepeatedEnumField(value: &self.movingTypeSamples) }()
      case 11: try { try decoder.decodeRepeatedSInt32Field(value: &self.accelerationMadSamples) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recordingIntervalMs {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.syncPoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.syncPoint, fieldNumber: 3)
    }
    if !self.sampleSource.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sampleSource, fieldNumber: 4)
    }
    if !self.heartRateSamples.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.heartRateSamples, fieldNumber: 5)
    }
    if !self.cadenceSamples.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.cadenceSamples, fieldNumber: 6)
    }
    if !self.speedSamples.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.speedSamples, fieldNumber: 7)
    }
    if !self.distanceSamples.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.distanceSamples, fieldNumber: 8)
    }
    if !self.forwardAccelerationSamples.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.forwardAccelerationSamples, fieldNumber: 9)
    }
    if !self.movingTypeSamples.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.movingTypeSamples, fieldNumber: 10)
    }
    if !self.accelerationMadSamples.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.accelerationMadSamples, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_PbExerciseIntervalledSample2List, rhs: Data_PbExerciseIntervalledSample2List) -> Bool {
    if lhs._sampleType != rhs._sampleType {return false}
    if lhs._recordingIntervalMs != rhs._recordingIntervalMs {return false}
    if lhs.syncPoint != rhs.syncPoint {return false}
    if lhs.sampleSource != rhs.sampleSource {return false}
    if lhs.heartRateSamples != rhs.heartRateSamples {return false}
    if lhs.cadenceSamples != rhs.cadenceSamples {return false}
    if lhs.speedSamples != rhs.speedSamples {return false}
    if lhs.distanceSamples != rhs.distanceSamples {return false}
    if lhs.forwardAccelerationSamples != rhs.forwardAccelerationSamples {return false}
    if lhs.accelerationMadSamples != rhs.accelerationMadSamples {return false}
    if lhs.movingTypeSamples != rhs.movingTypeSamples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseSamples2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PbExerciseSamples2"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exercise_intervalled_sample2_list"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.exerciseIntervalledSample2List) {return false}
    return true
  }

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exerciseIntervalledSample2List) }()
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exerciseIntervalledSample2List.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exerciseIntervalledSample2List, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Data_PbExerciseSamples2, rhs: Data_PbExerciseSamples2) -> Bool {
    if lhs.exerciseIntervalledSample2List != rhs.exerciseIntervalledSample2List {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
