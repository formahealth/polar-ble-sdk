// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pftp_request.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Query types (SAGRFC53).
/// Query parameters, if any, are transmitted in the following data (SAGRFC56)
/// and defined below, individually per query type. Responses to queries are
/// defined in pftp_response.proto.
enum Protocol_PbPFtpQuery: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case identifyDevice = 0
  case setSystemTime = 1
  case getSystemTime = 2
  case setLocalTime = 3
  case getLocalTime = 4
  case getDiskSpace = 5
  case generateChallengeToken = 6
  case setInternalTest = 7
  case getBatteryStatus = 8
  case setAdbMode = 9
  case cleanupDiskSpace = 10
  case getInactivityPreAlert = 11
  case prepareFirmwareUpdate = 12
  case requestSynchronization = 13
  case requestStartRecording = 14
  case requestStopRecording = 15
  case requestRecordingStatus = 16
  case generateAsymmetricKeys = 17
  case getDisplayStatus = 18
  case getVisualElements = 19
  case startExercise = 21
  case stopExercise = 22
  case pauseExercise = 23
  case resumeExercise = 24
  case getExerciseStatus = 25

  init() {
    self = .identifyDevice
  }

}

///
/// Class for PFTP filesystem operation and its parameters.
/// - For GET, ending directory delimiter in path designates directory listing operation. Otherwise, it's a read file operation.
/// - For PUT, ending directory delimiter in path designates directory creation. Otherwise, it's a write file operation.
/// - For PUT (when writing a file) and MERGE operations, the file is transmitted in following data.
/// - Other than PUT (when writing a file) and MERGE operations do not required additional data, only the path parameter.
/// - See SAGRFC56 for details.
struct Protocol_PbPFtpOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File operation command. The format of the path parameter affect to the command behavior. See SAGRFC56.
  var command: Protocol_PbPFtpOperation.Command {
    get {return _command ?? .get}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  /// Path to the target file or directory. Ending directory delimiter designates directory. See SAGRFC56.
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Command: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case get = 0
    case put = 1
    case merge = 2
    case remove = 3

    init() {
      self = .get
    }

  }

  init() {}

  fileprivate var _command: Protocol_PbPFtpOperation.Command? = nil
  fileprivate var _path: String? = nil
}

///
/// Parameters for SET_SYSTEM_TIME query.
struct Protocol_PbPFtpSetSystemTimeParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UTC date to be set.
  var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  /// UTC time to be set.
  var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// True, if date and time are from trusted source.
  var trusted: Bool {
    get {return _trusted ?? false}
    set {_trusted = newValue}
  }
  /// Returns true if `trusted` has been explicitly set.
  var hasTrusted: Bool {return self._trusted != nil}
  /// Clears the value of `trusted`. Subsequent reads from it will return its default value.
  mutating func clearTrusted() {self._trusted = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _trusted: Bool? = nil
}

///
/// Parameters for REQUEST_START_RECORDING query.
struct Protocol_PbPFtpRequestStartRecordingParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sampleType: PbSampleType {
    get {return _sampleType ?? .sampleTypeUndefined}
    set {_sampleType = newValue}
  }
  /// Returns true if `sampleType` has been explicitly set.
  var hasSampleType: Bool {return self._sampleType != nil}
  /// Clears the value of `sampleType`. Subsequent reads from it will return its default value.
  mutating func clearSampleType() {self._sampleType = nil}

  var recordingInterval: PbDuration {
    get {return _recordingInterval ?? PbDuration()}
    set {_recordingInterval = newValue}
  }
  /// Returns true if `recordingInterval` has been explicitly set.
  var hasRecordingInterval: Bool {return self._recordingInterval != nil}
  /// Clears the value of `recordingInterval`. Subsequent reads from it will return its default value.
  mutating func clearRecordingInterval() {self._recordingInterval = nil}

  var sampleDataIdentifier: String {
    get {return _sampleDataIdentifier ?? String()}
    set {_sampleDataIdentifier = newValue}
  }
  /// Returns true if `sampleDataIdentifier` has been explicitly set.
  var hasSampleDataIdentifier: Bool {return self._sampleDataIdentifier != nil}
  /// Clears the value of `sampleDataIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearSampleDataIdentifier() {self._sampleDataIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sampleType: PbSampleType? = nil
  fileprivate var _recordingInterval: PbDuration? = nil
  fileprivate var _sampleDataIdentifier: String? = nil
}

///
/// Parameters for SET_LOCAL_TIME query.
struct Protocol_PbPFtpSetLocalTimeParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Local date to be set.
  var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  /// Local time to be set.
  var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// If present (known), timezone offset in 1 minute precision (-12h = -720min to +14h = +840min).
  var tzOffset: Int32 {
    get {return _tzOffset ?? 0}
    set {_tzOffset = newValue}
  }
  /// Returns true if `tzOffset` has been explicitly set.
  var hasTzOffset: Bool {return self._tzOffset != nil}
  /// Clears the value of `tzOffset`. Subsequent reads from it will return its default value.
  mutating func clearTzOffset() {self._tzOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _tzOffset: Int32? = nil
}

///
/// Parameters for GENERATE_CHALLENGE_TOKEN query.
struct Protocol_PbPFtpGenerateChallengeTokenParams: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User's local id.
  var userID: UInt32 {
    get {return _userID ?? 0}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  mutating func clearUserID() {self._userID = nil}

  /// Exactly 16 bytes of random nonse.
  var nonse: Data {
    get {return _nonse ?? Data()}
    set {_nonse = newValue}
  }
  /// Returns true if `nonse` has been explicitly set.
  var hasNonse: Bool {return self._nonse != nil}
  /// Clears the value of `nonse`. Subsequent reads from it will return its default value.
  mutating func clearNonse() {self._nonse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userID: UInt32? = nil
  fileprivate var _nonse: Data? = nil
}

///
/// Parameters for SET_ADB_MODE query.
struct Protocol_PbPFtpSetAdbModeParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enable / disable adb mode
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enable: Bool? = nil
}

///
/// Parameters for CLEANUP_DISK_SPACE query.
struct Protocol_PbPFtpCleanupDiskSpaceParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of required free space in bytes
  var requiredBytes: UInt64 {
    get {return _requiredBytes ?? 0}
    set {_requiredBytes = newValue}
  }
  /// Returns true if `requiredBytes` has been explicitly set.
  var hasRequiredBytes: Bool {return self._requiredBytes != nil}
  /// Clears the value of `requiredBytes`. Subsequent reads from it will return its default value.
  mutating func clearRequiredBytes() {self._requiredBytes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requiredBytes: UInt64? = nil
}

///
/// Parameters for START_EXERCISE query.
struct Protocol_PbPFtpStartExerciseParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to sport ecosystem identifier
  var sportIdentifier: PbSportIdentifier {
    get {return _sportIdentifier ?? PbSportIdentifier()}
    set {_sportIdentifier = newValue}
  }
  /// Returns true if `sportIdentifier` has been explicitly set.
  var hasSportIdentifier: Bool {return self._sportIdentifier != nil}
  /// Clears the value of `sportIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearSportIdentifier() {self._sportIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sportIdentifier: PbSportIdentifier? = nil
}

///
/// Parameters for STOP_EXERCISE query.
struct Protocol_PbPFtpStopExerciseParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enable / disable saving the stopped exercise
  var save: Bool {
    get {return _save ?? false}
    set {_save = newValue}
  }
  /// Returns true if `save` has been explicitly set.
  var hasSave: Bool {return self._save != nil}
  /// Clears the value of `save`. Subsequent reads from it will return its default value.
  mutating func clearSave() {self._save = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _save: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_PbPFtpQuery: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDENTIFY_DEVICE"),
    1: .same(proto: "SET_SYSTEM_TIME"),
    2: .same(proto: "GET_SYSTEM_TIME"),
    3: .same(proto: "SET_LOCAL_TIME"),
    4: .same(proto: "GET_LOCAL_TIME"),
    5: .same(proto: "GET_DISK_SPACE"),
    6: .same(proto: "GENERATE_CHALLENGE_TOKEN"),
    7: .same(proto: "SET_INTERNAL_TEST"),
    8: .same(proto: "GET_BATTERY_STATUS"),
    9: .same(proto: "SET_ADB_MODE"),
    10: .same(proto: "CLEANUP_DISK_SPACE"),
    11: .same(proto: "GET_INACTIVITY_PRE_ALERT"),
    12: .same(proto: "PREPARE_FIRMWARE_UPDATE"),
    13: .same(proto: "REQUEST_SYNCHRONIZATION"),
    14: .same(proto: "REQUEST_START_RECORDING"),
    15: .same(proto: "REQUEST_STOP_RECORDING"),
    16: .same(proto: "REQUEST_RECORDING_STATUS"),
    17: .same(proto: "GENERATE_ASYMMETRIC_KEYS"),
    18: .same(proto: "GET_DISPLAY_STATUS"),
    19: .same(proto: "GET_VISUAL_ELEMENTS"),
    21: .same(proto: "START_EXERCISE"),
    22: .same(proto: "STOP_EXERCISE"),
    23: .same(proto: "PAUSE_EXERCISE"),
    24: .same(proto: "RESUME_EXERCISE"),
    25: .same(proto: "GET_EXERCISE_STATUS"),
  ]
}

extension Protocol_PbPFtpOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "path"),
  ]

  public var isInitialized: Bool {
    if self._command == nil {return false}
    if self._path == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpOperation, rhs: Protocol_PbPFtpOperation) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpOperation.Command: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "PUT"),
    2: .same(proto: "MERGE"),
    3: .same(proto: "REMOVE"),
  ]
}

extension Protocol_PbPFtpSetSystemTimeParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSetSystemTimeParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .same(proto: "trusted"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if self._trusted == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._trusted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._trusted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSetSystemTimeParams, rhs: Protocol_PbPFtpSetSystemTimeParams) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._trusted != rhs._trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpRequestStartRecordingParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpRequestStartRecordingParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .standard(proto: "recording_interval"),
    3: .standard(proto: "sample_data_identifier"),
  ]

  public var isInitialized: Bool {
    if self._sampleType == nil {return false}
    if self._recordingInterval == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._sampleType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recordingInterval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sampleDataIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recordingInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sampleDataIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpRequestStartRecordingParams, rhs: Protocol_PbPFtpRequestStartRecordingParams) -> Bool {
    if lhs._sampleType != rhs._sampleType {return false}
    if lhs._recordingInterval != rhs._recordingInterval {return false}
    if lhs._sampleDataIdentifier != rhs._sampleDataIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSetLocalTimeParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSetLocalTimeParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .standard(proto: "tz_offset"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._tzOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tzOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSetLocalTimeParams, rhs: Protocol_PbPFtpSetLocalTimeParams) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._tzOffset != rhs._tzOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateChallengeTokenParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGenerateChallengeTokenParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "nonse"),
  ]

  public var isInitialized: Bool {
    if self._userID == nil {return false}
    if self._nonse == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._nonse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nonse {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGenerateChallengeTokenParams, rhs: Protocol_PbPFtpGenerateChallengeTokenParams) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._nonse != rhs._nonse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSetAdbModeParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSetAdbModeParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public var isInitialized: Bool {
    if self._enable == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSetAdbModeParams, rhs: Protocol_PbPFtpSetAdbModeParams) -> Bool {
    if lhs._enable != rhs._enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpCleanupDiskSpaceParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpCleanupDiskSpaceParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_bytes"),
  ]

  public var isInitialized: Bool {
    if self._requiredBytes == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requiredBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requiredBytes {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpCleanupDiskSpaceParams, rhs: Protocol_PbPFtpCleanupDiskSpaceParams) -> Bool {
    if lhs._requiredBytes != rhs._requiredBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpStartExerciseParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpStartExerciseParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sport_identifier"),
  ]

  public var isInitialized: Bool {
    if self._sportIdentifier == nil {return false}
    if let v = self._sportIdentifier, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sportIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sportIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpStartExerciseParams, rhs: Protocol_PbPFtpStartExerciseParams) -> Bool {
    if lhs._sportIdentifier != rhs._sportIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpStopExerciseParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpStopExerciseParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "save"),
  ]

  public var isInitialized: Bool {
    if self._save == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._save) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._save {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpStopExerciseParams, rhs: Protocol_PbPFtpStopExerciseParams) -> Bool {
    if lhs._save != rhs._save {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
