// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pftp_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Class for presenting filesystem entry, i.e. file or directory.
/// - The entry is directory if the name ends to directory delimiter, i.e. '/' character. F.ex. "directory/" or "directory.ext/".
/// - Otherwise the entry is considered to be a file. F.ex. "file" or "file.ext".
/// - See PbPFtpDirectory below for response to a directory listing operation.
struct Protocol_PbPFtpEntry: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file or directory. Ending directory delimiter designates directory entry.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// Size of the file in bytes, or 0 for directory entry.
  var size: UInt64 {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {_uniqueStorage()._size = nil}

  /// If present, entry's creation date/time. I.e. instant of the first write.
  var created: PbSystemDateTime {
    get {return _storage._created ?? PbSystemDateTime()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// If present, entry's last modified date/time.  I.e. instant of the last write.
  var modified: PbSystemDateTime {
    get {return _storage._modified ?? PbSystemDateTime()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  mutating func clearModified() {_uniqueStorage()._modified = nil}

  /// If present, entry's last touched date/time. I.e. instant of the last read or write.
  var touched: PbSystemDateTime {
    get {return _storage._touched ?? PbSystemDateTime()}
    set {_uniqueStorage()._touched = newValue}
  }
  /// Returns true if `touched` has been explicitly set.
  var hasTouched: Bool {return _storage._touched != nil}
  /// Clears the value of `touched`. Subsequent reads from it will return its default value.
  mutating func clearTouched() {_uniqueStorage()._touched = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Response to GET directory list operation.
/// The PbPFtpDirectory message is to be transmitted in the response data (SAGRFC56).
struct Protocol_PbPFtpDirectory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of unique entries in a directory.
  var entries: [Protocol_PbPFtpEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Response data to IDENTIFY_DEVICE query in pftp_request.proto.
struct Protocol_PbPFtpIdentifyDeviceResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device's id (SAGRFC19).
  var deviceID: String {
    get {return _deviceID ?? String()}
    set {_deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  var hasDeviceID: Bool {return self._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  mutating func clearDeviceID() {self._deviceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceID: String? = nil
}

///
/// Response data to GET_SYSTEM_TIME query in pftp_request.proto.
struct Protocol_PbPFtpGetSystemTimeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UTC date.
  var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  /// UTC time.
  var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// True, if the date and time can be trusted.
  var trusted: Bool {
    get {return _trusted ?? false}
    set {_trusted = newValue}
  }
  /// Returns true if `trusted` has been explicitly set.
  var hasTrusted: Bool {return self._trusted != nil}
  /// Clears the value of `trusted`. Subsequent reads from it will return its default value.
  mutating func clearTrusted() {self._trusted = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _trusted: Bool? = nil
}

///
/// Response data to GET_LOCAL_TIME query in pftp_request.proto.
struct Protocol_PbPFtpGetLocalTimeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Local date.
  var date: PbDate {
    get {return _date ?? PbDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  /// Local time.
  var time: PbTime {
    get {return _time ?? PbTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// If present, timezone offset in 1 minute precision (-12h = -720min to +12h = +720min).
  var tzOffset: Int32 {
    get {return _tzOffset ?? 0}
    set {_tzOffset = newValue}
  }
  /// Returns true if `tzOffset` has been explicitly set.
  var hasTzOffset: Bool {return self._tzOffset != nil}
  /// Clears the value of `tzOffset`. Subsequent reads from it will return its default value.
  mutating func clearTzOffset() {self._tzOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: PbDate? = nil
  fileprivate var _time: PbTime? = nil
  fileprivate var _tzOffset: Int32? = nil
}

///
/// Response data to GET_DISK_SPACE and CLEANUP_DISK_SPACE queries in pftp_request.proto.
struct Protocol_PbPFtpDiskSpaceResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filesystem fragment size. Smallest allocatable filesystem unit.
  var fragmentSize: UInt32 {
    get {return _fragmentSize ?? 0}
    set {_fragmentSize = newValue}
  }
  /// Returns true if `fragmentSize` has been explicitly set.
  var hasFragmentSize: Bool {return self._fragmentSize != nil}
  /// Clears the value of `fragmentSize`. Subsequent reads from it will return its default value.
  mutating func clearFragmentSize() {self._fragmentSize = nil}

  /// Total size of the filesystem in fragments.
  var totalFragments: UInt64 {
    get {return _totalFragments ?? 0}
    set {_totalFragments = newValue}
  }
  /// Returns true if `totalFragments` has been explicitly set.
  var hasTotalFragments: Bool {return self._totalFragments != nil}
  /// Clears the value of `totalFragments`. Subsequent reads from it will return its default value.
  mutating func clearTotalFragments() {self._totalFragments = nil}

  /// Amount of available fragments.
  var freeFragments: UInt64 {
    get {return _freeFragments ?? 0}
    set {_freeFragments = newValue}
  }
  /// Returns true if `freeFragments` has been explicitly set.
  var hasFreeFragments: Bool {return self._freeFragments != nil}
  /// Clears the value of `freeFragments`. Subsequent reads from it will return its default value.
  mutating func clearFreeFragments() {self._freeFragments = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fragmentSize: UInt32? = nil
  fileprivate var _totalFragments: UInt64? = nil
  fileprivate var _freeFragments: UInt64? = nil
}

///
/// Response data to GENERATE_CHALLENGE_TOKEN query in pftp_request.proto.
struct Protocol_PbPFtpGenerateChallengeTokenResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Generated challenge token. Exactly 16 bytes.
  var token: Data {
    get {return _token ?? Data()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: Data? = nil
}

///
/// Response data to GENERATE_ASYMMETRIC_KEYS query in pftp_request.proto.
struct Protocol_PbPFtpGenerateAsymmetricKeysResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Generated public key, can only be created once.
  ///For Bugatti/Macan first byte is 0x01, Remaining 33 bytes contain sec256k1 public key in compressed format.
  ///same data is also saved to file /SYS/KEYS/PUBLIC
  var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  ///asymmetric_key_format defines the format of the public_key
  var asymmetricKeyFormat: Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat {
    get {return _asymmetricKeyFormat ?? .sec256KlCompressed}
    set {_asymmetricKeyFormat = newValue}
  }
  /// Returns true if `asymmetricKeyFormat` has been explicitly set.
  var hasAsymmetricKeyFormat: Bool {return self._asymmetricKeyFormat != nil}
  /// Clears the value of `asymmetricKeyFormat`. Subsequent reads from it will return its default value.
  mutating func clearAsymmetricKeyFormat() {self._asymmetricKeyFormat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbAsymmetricKeyFormat: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    ///For Bugatti/Macan first byte is 0x01, Remaining 33 bytes contain sec256k1 public key in compressed format.
    case sec256KlCompressed = 0

    init() {
      self = .sec256KlCompressed
    }

  }

  init() {}

  fileprivate var _publicKey: Data? = nil
  fileprivate var _asymmetricKeyFormat: Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat? = nil
}

///
/// Response data to GET_BATTERY_STATUS query in pftp_request.proto and used as
/// parameters in BATTERY_STATUS notification defined in pftp_notification.proto.
struct Protocol_PbPFtpBatteryStatusResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Battery status in percentage
  /// Range [0-100%]
  var batteryStatus: UInt32 {
    get {return _batteryStatus ?? 0}
    set {_batteryStatus = newValue}
  }
  /// Returns true if `batteryStatus` has been explicitly set.
  var hasBatteryStatus: Bool {return self._batteryStatus != nil}
  /// Clears the value of `batteryStatus`. Subsequent reads from it will return its default value.
  mutating func clearBatteryStatus() {self._batteryStatus = nil}

  var charging: Bool {
    get {return _charging ?? false}
    set {_charging = newValue}
  }
  /// Returns true if `charging` has been explicitly set.
  var hasCharging: Bool {return self._charging != nil}
  /// Clears the value of `charging`. Subsequent reads from it will return its default value.
  mutating func clearCharging() {self._charging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batteryStatus: UInt32? = nil
  fileprivate var _charging: Bool? = nil
}

///
/// Response data to GET_INACTIVITY_PRE_ALERT query in pftp_request.proto.
struct Protocol_PbPFtpGetInactivityPreAlertResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True, if inactivity pre-alert has triggered. False after pre-alert's time window has expired.
  var inactivityPreAlertOn: Bool {
    get {return _inactivityPreAlertOn ?? false}
    set {_inactivityPreAlertOn = newValue}
  }
  /// Returns true if `inactivityPreAlertOn` has been explicitly set.
  var hasInactivityPreAlertOn: Bool {return self._inactivityPreAlertOn != nil}
  /// Clears the value of `inactivityPreAlertOn`. Subsequent reads from it will return its default value.
  mutating func clearInactivityPreAlertOn() {self._inactivityPreAlertOn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inactivityPreAlertOn: Bool? = nil
}

///
/// Response data to REQUEST_RECORDING_STATUS query in pftp_request.proto.
struct Protocol_PbRequestRecordingStatusResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recordingOn: Bool {
    get {return _recordingOn ?? false}
    set {_recordingOn = newValue}
  }
  /// Returns true if `recordingOn` has been explicitly set.
  var hasRecordingOn: Bool {return self._recordingOn != nil}
  /// Clears the value of `recordingOn`. Subsequent reads from it will return its default value.
  mutating func clearRecordingOn() {self._recordingOn = nil}

  var sampleDataIdentifier: String {
    get {return _sampleDataIdentifier ?? String()}
    set {_sampleDataIdentifier = newValue}
  }
  /// Returns true if `sampleDataIdentifier` has been explicitly set.
  var hasSampleDataIdentifier: Bool {return self._sampleDataIdentifier != nil}
  /// Clears the value of `sampleDataIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearSampleDataIdentifier() {self._sampleDataIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recordingOn: Bool? = nil
  fileprivate var _sampleDataIdentifier: String? = nil
}

///
/// Response data to GET_DISPLAY_STATUS query in pftp_request.proto.
struct Protocol_PbRequestDisplayStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayOn: Bool {
    get {return _displayOn ?? false}
    set {_displayOn = newValue}
  }
  /// Returns true if `displayOn` has been explicitly set.
  var hasDisplayOn: Bool {return self._displayOn != nil}
  /// Clears the value of `displayOn`. Subsequent reads from it will return its default value.
  mutating func clearDisplayOn() {self._displayOn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _displayOn: Bool? = nil
}

///
/// Response data to GET_VISUAL_ELEMENTS query in pftp_request.proto.
struct Protocol_PbPFtpGetVisualElementsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to visual elements data file.
  var visualDataPath: String {
    get {return _visualDataPath ?? String()}
    set {_visualDataPath = newValue}
  }
  /// Returns true if `visualDataPath` has been explicitly set.
  var hasVisualDataPath: Bool {return self._visualDataPath != nil}
  /// Clears the value of `visualDataPath`. Subsequent reads from it will return its default value.
  mutating func clearVisualDataPath() {self._visualDataPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _visualDataPath: String? = nil
}

///
/// Response data to START_EXERCISE query in pftp_request.proto.
struct Protocol_PbPftpStartExerciseResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Protocol_PbPftpStartExerciseResult.PbStartExerciseResult {
    get {return _result ?? .resultOther}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var startTime: PbLocalDateTime {
    get {return _startTime ?? PbLocalDateTime()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbStartExerciseResult: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case resultOther = 0
    case resultSuccess = 1
    case resultExeOngoing = 2
    case resultLowBattery = 3
    case resultSdkMode = 4
    case resultUnknownSport = 5

    init() {
      self = .resultOther
    }

  }

  init() {}

  fileprivate var _result: Protocol_PbPftpStartExerciseResult.PbStartExerciseResult? = nil
  fileprivate var _startTime: PbLocalDateTime? = nil
}

///
/// Response data to STOP_EXERCISE query in pftp_request.proto.
struct Protocol_PbPftpStopExerciseResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Protocol_PbPftpStopExerciseResult.PbStopExerciseResult {
    get {return _result ?? .resultOther}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbStopExerciseResult: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case resultOther = 0
    case resultSuccess = 1
    case resultExeNotRunning = 2

    init() {
      self = .resultOther
    }

  }

  init() {}

  fileprivate var _result: Protocol_PbPftpStopExerciseResult.PbStopExerciseResult? = nil
}

///
/// Response data to PAUSE_EXERCISE query in pftp_request.proto.
struct Protocol_PbPftpPauseExerciseResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Protocol_PbPftpPauseExerciseResult.PbPauseExerciseResult {
    get {return _result ?? .resultOther}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbPauseExerciseResult: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case resultOther = 0
    case resultSuccess = 1
    case resultExeNotRunning = 2
    case resultAlreadyPaused = 3
    case resultPauseNotAvailable = 4

    init() {
      self = .resultOther
    }

  }

  init() {}

  fileprivate var _result: Protocol_PbPftpPauseExerciseResult.PbPauseExerciseResult? = nil
}

///
/// Response data to RESUME_EXERCISE query in pftp_request.proto.
struct Protocol_PbPftpResumeExerciseResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Protocol_PbPftpResumeExerciseResult.PbResumeExerciseResult {
    get {return _result ?? .resultOther}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbResumeExerciseResult: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case resultOther = 0
    case resultSuccess = 1
    case resultExeNotRunning = 2
    case resultNotPaused = 3

    init() {
      self = .resultOther
    }

  }

  init() {}

  fileprivate var _result: Protocol_PbPftpResumeExerciseResult.PbResumeExerciseResult? = nil
}

///
/// Response data to GET_EXERCISE_STATUS query in pftp_request.proto.
struct Protocol_PbPftpGetExerciseStatusResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exerciseState: Protocol_PbPftpGetExerciseStatusResult.PbExerciseState {
    get {return _exerciseState ?? .exerciseStateOther}
    set {_exerciseState = newValue}
  }
  /// Returns true if `exerciseState` has been explicitly set.
  var hasExerciseState: Bool {return self._exerciseState != nil}
  /// Clears the value of `exerciseState`. Subsequent reads from it will return its default value.
  mutating func clearExerciseState() {self._exerciseState = nil}

  var exerciseType: Protocol_PbPftpGetExerciseStatusResult.PbExerciseType {
    get {return _exerciseType ?? .exerciseTypeOther}
    set {_exerciseType = newValue}
  }
  /// Returns true if `exerciseType` has been explicitly set.
  var hasExerciseType: Bool {return self._exerciseType != nil}
  /// Clears the value of `exerciseType`. Subsequent reads from it will return its default value.
  mutating func clearExerciseType() {self._exerciseType = nil}

  var sportIdentifier: PbSportIdentifier {
    get {return _sportIdentifier ?? PbSportIdentifier()}
    set {_sportIdentifier = newValue}
  }
  /// Returns true if `sportIdentifier` has been explicitly set.
  var hasSportIdentifier: Bool {return self._sportIdentifier != nil}
  /// Clears the value of `sportIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearSportIdentifier() {self._sportIdentifier = nil}

  var startTime: PbLocalDateTime {
    get {return _startTime ?? PbLocalDateTime()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbExerciseState: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case exerciseStateOther = 0
    case exerciseStateRunning = 1
    case exerciseStatePaused = 2
    case exerciseStateOff = 3

    init() {
      self = .exerciseStateOther
    }

  }

  enum PbExerciseType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case exerciseTypeOther = 0
    case exerciseTypeNormal = 1
    case exerciseTypeRemote = 2
    case exerciseTypeAutomatic = 3

    init() {
      self = .exerciseTypeOther
    }

  }

  init() {}

  fileprivate var _exerciseState: Protocol_PbPftpGetExerciseStatusResult.PbExerciseState? = nil
  fileprivate var _exerciseType: Protocol_PbPftpGetExerciseStatusResult.PbExerciseType? = nil
  fileprivate var _sportIdentifier: PbSportIdentifier? = nil
  fileprivate var _startTime: PbLocalDateTime? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_PbPFtpEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "size"),
    3: .same(proto: "created"),
    4: .same(proto: "modified"),
    5: .same(proto: "touched"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _size: UInt64? = nil
    var _created: PbSystemDateTime? = nil
    var _modified: PbSystemDateTime? = nil
    var _touched: PbSystemDateTime? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _size = source._size
      _created = source._created
      _modified = source._modified
      _touched = source._touched
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if _storage._size == nil {return false}
      if let v = _storage._created, !v.isInitialized {return false}
      if let v = _storage._modified, !v.isInitialized {return false}
      if let v = _storage._touched, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._size) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._modified) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._touched) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._touched {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpEntry, rhs: Protocol_PbPFtpEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._modified != rhs_storage._modified {return false}
        if _storage._touched != rhs_storage._touched {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpDirectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpDirectory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpDirectory, rhs: Protocol_PbPFtpDirectory) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpIdentifyDeviceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpIdentifyDeviceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  public var isInitialized: Bool {
    if self._deviceID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpIdentifyDeviceResult, rhs: Protocol_PbPFtpIdentifyDeviceResult) -> Bool {
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetSystemTimeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGetSystemTimeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .same(proto: "trusted"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if self._trusted == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._trusted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._trusted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGetSystemTimeResult, rhs: Protocol_PbPFtpGetSystemTimeResult) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._trusted != rhs._trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetLocalTimeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGetLocalTimeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .standard(proto: "tz_offset"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._time == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._tzOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tzOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGetLocalTimeResult, rhs: Protocol_PbPFtpGetLocalTimeResult) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._time != rhs._time {return false}
    if lhs._tzOffset != rhs._tzOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpDiskSpaceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpDiskSpaceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fragment_size"),
    2: .standard(proto: "total_fragments"),
    3: .standard(proto: "free_fragments"),
  ]

  public var isInitialized: Bool {
    if self._fragmentSize == nil {return false}
    if self._totalFragments == nil {return false}
    if self._freeFragments == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._fragmentSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._totalFragments) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._freeFragments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fragmentSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalFragments {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._freeFragments {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpDiskSpaceResult, rhs: Protocol_PbPFtpDiskSpaceResult) -> Bool {
    if lhs._fragmentSize != rhs._fragmentSize {return false}
    if lhs._totalFragments != rhs._totalFragments {return false}
    if lhs._freeFragments != rhs._freeFragments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateChallengeTokenResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGenerateChallengeTokenResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public var isInitialized: Bool {
    if self._token == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGenerateChallengeTokenResult, rhs: Protocol_PbPFtpGenerateChallengeTokenResult) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateAsymmetricKeysResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGenerateAsymmetricKeysResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "asymmetric_key_format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._asymmetricKeyFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asymmetricKeyFormat {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGenerateAsymmetricKeysResult, rhs: Protocol_PbPFtpGenerateAsymmetricKeysResult) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._asymmetricKeyFormat != rhs._asymmetricKeyFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGenerateAsymmetricKeysResult.PbAsymmetricKeyFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEC256KL_COMPRESSED"),
  ]
}

extension Protocol_PbPFtpBatteryStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpBatteryStatusResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "battery_status"),
    2: .same(proto: "charging"),
  ]

  public var isInitialized: Bool {
    if self._batteryStatus == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._batteryStatus) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._charging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batteryStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._charging {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpBatteryStatusResult, rhs: Protocol_PbPFtpBatteryStatusResult) -> Bool {
    if lhs._batteryStatus != rhs._batteryStatus {return false}
    if lhs._charging != rhs._charging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetInactivityPreAlertResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGetInactivityPreAlertResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inactivity_pre_alert_on"),
  ]

  public var isInitialized: Bool {
    if self._inactivityPreAlertOn == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._inactivityPreAlertOn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inactivityPreAlertOn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGetInactivityPreAlertResult, rhs: Protocol_PbPFtpGetInactivityPreAlertResult) -> Bool {
    if lhs._inactivityPreAlertOn != rhs._inactivityPreAlertOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbRequestRecordingStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbRequestRecordingStatusResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recording_on"),
    2: .standard(proto: "sample_data_identifier"),
  ]

  public var isInitialized: Bool {
    if self._recordingOn == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._recordingOn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sampleDataIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recordingOn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sampleDataIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbRequestRecordingStatusResult, rhs: Protocol_PbRequestRecordingStatusResult) -> Bool {
    if lhs._recordingOn != rhs._recordingOn {return false}
    if lhs._sampleDataIdentifier != rhs._sampleDataIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbRequestDisplayStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbRequestDisplayStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_on"),
  ]

  public var isInitialized: Bool {
    if self._displayOn == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._displayOn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayOn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbRequestDisplayStatus, rhs: Protocol_PbRequestDisplayStatus) -> Bool {
    if lhs._displayOn != rhs._displayOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGetVisualElementsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGetVisualElementsResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visual_data_path"),
  ]

  public var isInitialized: Bool {
    if self._visualDataPath == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._visualDataPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._visualDataPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGetVisualElementsResult, rhs: Protocol_PbPFtpGetVisualElementsResult) -> Bool {
    if lhs._visualDataPath != rhs._visualDataPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpStartExerciseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpStartExerciseResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "start_time"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    if let v = self._startTime, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpStartExerciseResult, rhs: Protocol_PbPftpStartExerciseResult) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpStartExerciseResult.PbStartExerciseResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_OTHER"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_EXE_ONGOING"),
    3: .same(proto: "RESULT_LOW_BATTERY"),
    4: .same(proto: "RESULT_SDK_MODE"),
    5: .same(proto: "RESULT_UNKNOWN_SPORT"),
  ]
}

extension Protocol_PbPftpStopExerciseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpStopExerciseResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpStopExerciseResult, rhs: Protocol_PbPftpStopExerciseResult) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpStopExerciseResult.PbStopExerciseResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_OTHER"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_EXE_NOT_RUNNING"),
  ]
}

extension Protocol_PbPftpPauseExerciseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpPauseExerciseResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpPauseExerciseResult, rhs: Protocol_PbPftpPauseExerciseResult) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPauseExerciseResult.PbPauseExerciseResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_OTHER"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_EXE_NOT_RUNNING"),
    3: .same(proto: "RESULT_ALREADY_PAUSED"),
    4: .same(proto: "RESULT_PAUSE_NOT_AVAILABLE"),
  ]
}

extension Protocol_PbPftpResumeExerciseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpResumeExerciseResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpResumeExerciseResult, rhs: Protocol_PbPftpResumeExerciseResult) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpResumeExerciseResult.PbResumeExerciseResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_OTHER"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_EXE_NOT_RUNNING"),
    3: .same(proto: "RESULT_NOT_PAUSED"),
  ]
}

extension Protocol_PbPftpGetExerciseStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpGetExerciseStatusResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exercise_state"),
    2: .standard(proto: "exercise_type"),
    3: .standard(proto: "sport_identifier"),
    4: .standard(proto: "start_time"),
  ]

  public var isInitialized: Bool {
    if self._exerciseState == nil {return false}
    if let v = self._sportIdentifier, !v.isInitialized {return false}
    if let v = self._startTime, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._exerciseState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._exerciseType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sportIdentifier) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exerciseState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exerciseType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sportIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpGetExerciseStatusResult, rhs: Protocol_PbPftpGetExerciseStatusResult) -> Bool {
    if lhs._exerciseState != rhs._exerciseState {return false}
    if lhs._exerciseType != rhs._exerciseType {return false}
    if lhs._sportIdentifier != rhs._sportIdentifier {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpGetExerciseStatusResult.PbExerciseState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXERCISE_STATE_OTHER"),
    1: .same(proto: "EXERCISE_STATE_RUNNING"),
    2: .same(proto: "EXERCISE_STATE_PAUSED"),
    3: .same(proto: "EXERCISE_STATE_OFF"),
  ]
}

extension Protocol_PbPftpGetExerciseStatusResult.PbExerciseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXERCISE_TYPE_OTHER"),
    1: .same(proto: "EXERCISE_TYPE_NORMAL"),
    2: .same(proto: "EXERCISE_TYPE_REMOTE"),
    3: .same(proto: "EXERCISE_TYPE_AUTOMATIC"),
  ]
}
