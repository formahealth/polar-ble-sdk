syntax = "proto2";

package protocol;

import "types.proto";
import "structures.proto";


message PbPFtpEntry {
  required string name = 1;
  required uint64 size = 2;
  optional PbSystemDateTime created = 3;
  optional PbSystemDateTime modified = 4;
  optional PbSystemDateTime touched = 5;
}

message PbPFtpDirectory {
  repeated PbPFtpEntry entries = 1;
}

message PbRequestRecordingStatusResult {
  required bool recording_on = 1;
  optional string sample_data_identifier = 2;
}

message PbPFtpDiskSpaceResult {
  required uint32 fragment_size = 1;
  required uint64 total_fragments = 2;
  required uint64 free_fragments = 3;
}

/*
 * Response data to RESUME_EXERCISE query in pftp_request.proto.
 */
message PbPftpResumeExerciseResult {
  enum PbResumeExerciseResult {
    RESULT_OTHER               = 0;
    RESULT_SUCCESS             = 1;
    RESULT_EXE_NOT_RUNNING     = 2;
    RESULT_NOT_PAUSED          = 3;
  }
  required PbResumeExerciseResult result = 1;
}

/*
 * Response data to GET_EXERCISE_STATUS query in pftp_request.proto.
 */
message PbPftpGetExerciseStatusResult {
  enum PbExerciseState {
    EXERCISE_STATE_OTHER    = 0;
    EXERCISE_STATE_RUNNING  = 1;
    EXERCISE_STATE_PAUSED   = 2;
    EXERCISE_STATE_OFF      = 3;
  }

  enum PbExerciseType {
    EXERCISE_TYPE_OTHER     = 0;
    EXERCISE_TYPE_NORMAL    = 1;
    EXERCISE_TYPE_REMOTE    = 2;
    EXERCISE_TYPE_AUTOMATIC = 3;
  }
  required PbExerciseState exercise_state     = 1;
  optional PbExerciseType exercise_type       = 2;
  optional PbSportIdentifier sport_identifier = 3;
  optional PbLocalDateTime start_time         = 4;
}